% !TEX root = ../md2-user-handbook.tex
% !TeX spellcheck = en_GB
% !TeX program = xelatex

\lstset{language=Simple}

The \MD backend is implemented in Java. It is automatically generated by from the \MD model. Note, that some parts of the backend are static while others are contingent upon the model.

\subsection{Beans}
\label{subsec:beans}
For entities that are used in at least one remote content provider a stateless session bean is generated. Such a bean provides basic methods to create or manipulate entities of its type. The Java Persistence API (JPA) is used for the persistent storage of the data. The persistence configuration file is located at \lstinline|META-INF/persistence.xml|. Currently, EclipseLink is used as persistence service.

Additionally, a static session bean is generated for the workflow state of the instances of a workflow. Internally, a workflow instance is identified by an unique ID that is represented as an integer. However, since a workflow instance is generated at the client side, a single client cannot assure that a specific number is not used by another workflow instance of another client. Therefore, every client generates its own \lstinline|instanceId| that is a hash value of the current time and other variables, and thus supposed to be unique. This generated hash value is represented as a string value.

\subsection{Datatypes}
The datatypes used in the backend are static and implemented as simple wrappers. For instance, every entity has a unique internal identification number (\lstinline|internalID|) that is an integer value. The respective wrapper implementation is depicted in the following listing. 

\begin{lstlisting}[language=Java, label=lst:intIdWrapper, caption=An integer wrapper for the internal identification number]
@XmlRootElement(name = "internalId")
public class InternalIdWrapper {
	
	@XmlElement
	protected int __internalId;
	
	protected InternalIdWrapper() {
		// no-arg default constructor necessary
	}
	
	public InternalIdWrapper(int integer) {
		this.__internalId = integer;
	}
}
\end{lstlisting}

\subsection{Entities}
The entities and enumerations defined in the \MD model are generated into the subpackage \lstinline|entities.models|. Moreover, two static Java classes are generated:  \lstinline|RequestDTO| and \lstinline|WorkflowState|. The former is used as an encapsulation for all client requests, \eg to create a corresponding REST request. The latter is used as a representation of the state a particular workflow instance has. A workflow can consist of multiple workflow elements, that in turn can fire different events. Thus, every started workflow (\ie every workflow instance) must keep track of its current workflow element and the last event fired in it.

\subsection{File Download Servlet}
This servlet is used to deliver uploaded files to a requesting client. It is accessible at the path \lstinline|/DownloadFile| below the web root of your deployed project. 

In a \lstinline[language=Simple]|GET| request to this servlet you need to set the parameter \lstinline|file| to the identifier of an uploaded file, which was returned by the file upload web service before (cf. \Cref{fig:remoteFileUpload}). 
All files are stored in the file system. Therefore, the download servlet needs to look for files using the identifier in a central directory, which is also referenced by the upload web service. This location  is defined in the generated \lstinline[language=Java]|Config.UPLOAD_FILE_STORAGE_PATH|, which is derived from the \lstinline|storagePath| element in the file upload remote connection in your model.

Note, that currently only images can be delivered as the download servlet assumes the content type to be \lstinline|image/jpeg|. This could be changed in the future by storing the correct content type during upload and retrieving it in this servlet.

\subsection{Web Services}
Similar to the generation of the stateless session beans, a web service is only generated for those entities that are used in at least one remote content provider. Those web services provide simple access to entity data.
Additionally, some static web service are generated that are used for specific features. Those are explained in the following.

\subsubsection{Calls to External Webservices}
As a simple way to interact with external services, a web service \lstinline|CallExternalWebServiceWS| in the backend allows to call another web service, that might be on a different system or server. The web service in the backend provides a method that takes a JSON-encoded object as an input. This object must contain the URL, the REST method type and the set of parameters of that method. For example, the following listing depicts how such a JSON object is constructed in map.apps.

\todo{Add workaround for HashMap @CARO, @JAN, @MALTE}

\begin{lstlisting}[language=Javascript, label=lst:callExtWSJSON, caption=JSON-encoded object containing information to call an external web service]
data: json.stringify({
  "url": this._url,
  "requestMethod": this._method,
  "queryParams": this._queryParams,
  "body": this._bodyParams
})
\end{lstlisting}

\subsubsection{Offer Webservices to Start Workflow}
Besides the possibility to start a workflow through an app it is possible to invoke it using a webservice. The description of the corresponding model language is described in \Cref{subsec: WorkflowControlThroughWS}. For each invokable workflow element a webservice is created and for each invoke definition a webservice endpoint is specified, including the defined parameters and the creation of the required entities. After the entities are saved using the internal beans, a \lstinline|workflowState| is persisted using the workflow element the webservice belongs to. Additionally, the \lstinline|lastEventFired| is set to the defined text specified in the workflow model after the \lstinline[language=MD2]|invokable| keyword, or to a default if not specified. The entity IDs returned by the internal beans are then injected as the content provider IDs. Directly afterwards, the workflow instance is accessible within the list of open issues of all app that are allowed to view the invoked workflow element. Since a new workflow instance is created, the backend is creating a new random UUID for each webservice call.

For each endpoint a method \lstinline|@POST| or \lstinline|@PUT| can be defined. The used parameter types are \lstinline|@FormParam|. The path which has to be used to call the webservice endpoint consists of the workflow element name and the specified path in the invoke definition.

\subsubsection{Event Handler} 

For the communication across apps, the backend offers an event handler web service. This web service handles all workflow events that are fired in one app and need to start a workflow element in another app. Required parameters for this web service are

\begin{itemize}
\item the instance ID of the workflow instance,
\item the event which was fired,
\item the content provider IDs,
\item and the current workflow element which fired the event.
\end{itemize}

The event handler web service uses these parameters to perform adjustments in the workflow state of the current workflow instance. This includes setting the last event fired and the current workflow element. Furthermore, the content provider IDs are stored in the workflow state so that subsequent apps can load data from content providers using these IDs.

\subsubsection{Workflow State} 

The workflow state web service allows to retrieve open workflow instances or add new ones. Whenever the list of open issues is opened in an app, this app sends its name to the workflow state web service. The web service then returns all workflow states whose current workflow element is part of the app with the given app name. For this purpose, the belongingness of workflow elements to apps is originally derived from the DSL model and stored in a hashmap in the backend.

Furthermore, for every new workflow instance, a new workflow state needs to be created. To do so, the workflow state web service is called as soon as the app which started the workflow hands the control over to the backend. This app generates a globally unique identifier (as described in \Cref{subsec:beans}) and provides it in the web service call.

\subsubsection{File Upload}

As another web service, a REST endpoint for uploading files is provided.
In contrast to the other web services, it expects an input format of \lstinline|MULTIPART_FORM_DATA|, thus allowing image uploads from HTML forms.

Given an uploaded file, it creates a file with a unique file name using the \lstinline[language=Java]|File.createTempFile()| interface. The file is stored in the location specified in \lstinline[language=Java]|Config.UPLOAD_FILE_STORAGE_PATH| (or \lstinline|storagePath|) and the generated file name is returned to the invoking client. No further information about the file is stored or checked, \ie original file name and content type are lost.

\subsubsection{Version Negotiation} 
This web service can be used by generated apps to check whether they were generated from the same model version as the backend. Consequently, this is only useful if the modeller updates the model version after making changes to the data model.
