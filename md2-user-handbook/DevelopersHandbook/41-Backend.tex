% !TEX root = ../md2-user-handbook.tex
% !TeX spellcheck = en_GB
% !TeX program = xelatex

\lstset{language=Simple}

The \MD backend is implemented in Java. It is generated by the \MD framework from the \MD model. Some code in the backend is static, though. 

\subsection{Beans}
\label{subsec:beans}
For entities that are used in at least one remote content provider a stateless session bean is generated. Such a bean provides basic methods to create or manipulate entities of that bean. JPA is used for the persistent storage of the data. The persistence configuration file is located at \lstinline|META-INF/persistence.xml|. Currently, EclipseLink as persistence service.

Additionally, a static session bean is generated for the workflow state of the instances of a workflow. Internally, a workflow instance is identified by an identification number that is represented as an integer. However, since a workflow instance is generated at the client side, a single client cannot assure that a specific number is not used by another workflow instance of another client. Therefore, every client generates its own \lstinline|instanceId| that is a hash value of the current time (among others), and thus a quite likely unique identification value. This generated hash value is represented as a string value.

\subsection{Datatypes}
The datatypes used in the backend are static and implemented as simple wrappers. For instance, every entity has a unique internal identification number (\lstinline|internalID|) that is an integer value. The respective wrapper implementation is depicted in the following listing. 

\begin{lstlisting}[language=Java, label=lst:intIdWrapper, caption=An integer wrapper for the internal identification number]
@XmlRootElement(name = "internalId")
public class InternalIdWrapper {
	
	@XmlElement
	protected int __internalId;
	
	protected InternalIdWrapper() {
		// no-arg default constructor necessary
	}
	
	public InternalIdWrapper(int integer) {
		this.__internalId = integer;
	}
}
\end{lstlisting}

\subsection{Entities}
The entities and enumerations defined in the \MD model are generated into the subpackage \lstinline|entities.models|. Moreover, two static Java classes are generated:  \lstinline|RequestDTO| and \lstinline|WorkflowState|. The former is used as an encapsulation for all client requests, e.g., to create a corresponding REST request. The latter is used as a representation of the state an instance of a workflow has. A workflow can consist of multiple workflow elements, that in turn can fire different events. Thus, every started workflow (i.e. every workflow instance) must keep track of its current workflow element and the last fired event in it.

\subsection{File Download Servlet}\todo{Please give me a description... @JAN}

\subsection{Web Services}
Similar to the generation of the stateless session beans, a web service is only generated for those entities that are used in at least one remote content provider. Those web service provide a simple access to the entity data.

Additionally, some static web service are generated that are used for specific features. Those web services are explained in the following.
\subsubsection{Calls to External Webservices}
As a simple way to interact with external services, a web service \lstinline|CallExternalWebServiceWS| in the backend allows to call another web service, that might be on a different system or server. The web service in the backend provides a method that takes a JSON-encoded object as an input. This object must contain the URL, the REST method type and the set of parameters of that method. For example, the following listing depicts how such a JSON object is constructed in map.apps.

\begin{lstlisting}[language=Javascript, label=lst:callExtWSJSON, caption=JSON-encoded object containing information to call an external web service]
data: json.stringify({
  "url": this._url,
  "requestMethod": this._method,
  "queryParams": this._queryParams,
  "body": this._bodyParams
})
\end{lstlisting}

\subsubsection{Offer Webservices to Start Workflow}
Besides the possibility to start a workflow through an app it is possible to invoke it using a webservice. The description of the according language is described in \cref{subsec: WorkflowControlThroughWS}. For each invokable workflow element a webservice is created and for each invoke definition a webservice endpoint is specified, including the defined parameters and the creation of the needed entities. After the entities are saved using the internal beans, a \lstinline|workflowState| is persisted using the workflow element the webservice belongs to. Additionally the \lstinline|lastEventFired| is set to the defined text specified in the workflow model after the \lstinline[language=MD2]|invokable| keyword or a default if not specified. The entity ids returned by the internal beans are then injected as the content provider ids. Directly afterwards the workflow instance is accessible within the list of open issues of an app allowed to view the invoked workflow element. Since a new workflow instance is created the backend is creating a new random UUID for each webservice call.

For each endpoint a method \lstinline|@POST| or \lstinline|@PUT| can be defined. The used parameter types are \lstinline|@FormParam|. The path which has to be used to call the webservice endpoint consists of the workflow element name and the specified path in the invoke definition.

\subsubsection{Event Handler} 

For the communication across apps, the backend offers an event handler web service. This web service handles all workflow events that are fired in one app and start a workflow element in another app, i.e. it is necessary for all switches between apps. Required parameters for this web service are

\begin{itemize}
\item the instance ID of the workflow instance,
\item the event which was fired,
\item the content provider IDs,
\item and the current workflow element which fired the event.
\end{itemize}

The event handler web service uses these parameters to perform adjustments in the workflow state of the current workflow instance. This includes setting the last event fired and the current workflow element. Furthermore, the content provider IDs are stored in the workflow state so that subsequent apps can load data from content providers using these IDs.

\subsubsection{Workflow State} 

The workflow state web service allows to retrieve open workflow instances or add new ones. Whenever the list of open issues is opened in an app, this app sends its name to the workflow state web service. The web service then returns all workflow states whose current workflow element is part of the app with the given app name. For this purpose, the belongingness of workflow elements to apps is originally derived from the DSL model and stored in a hashmap in the backend.

Furthermore, for every new workflow instance, a new workflow state needs to be created. To do so, the workflow state web service is called as soon as the app which started the workflow hands the control over to the backend. This app generates a globally unique if as described in \ref{subsec:beans} and provides it in the web service call.

\subsubsection{File Upload} \todo{@JAN Please give me a description...}

\subsubsection{Version Negotiation} 
This web service can be used by generated apps to check whether they were generated from the same model version as the backend. Consequently, this is only useful if the modeller always changes the model version after making changes to the data model.